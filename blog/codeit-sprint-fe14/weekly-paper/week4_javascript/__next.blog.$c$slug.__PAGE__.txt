1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T1c5f,<h1>1. var, let, const 비교 (중복 선언 허용, 스코프, 호이스팅)</h1>
<p>| 특성                 | var                   | let             | const           |
| ------------------ | --------------------- | --------------- | --------------- |
| 중복 선언 허용           | O                     | X               | X               |
| 스코프(Scope)     | 함수 스코프                | 블록 스코프          | 블록 스코프          |
| 호이스팅(Hoisting) | 선언+초기화(undefined) | 선언만 (초기화 X) | 선언만 (초기화 X) |
| 재할당 가능 여부          | O                     | O               | X               |</p>
<h3>중복 선언 허용</h3>
<ul>
<li>var은 동일한 변수명을 여러 번 선언할 수 있지만, <strong>let과 const는 중복 선언이 불가능</strong>하다.</li>
</ul>
<pre><code class="language-js">var a = 1;
var a = 2; // 가능

let b = 1;
let b = 2; // 에러 발생 (SyntaxError)

const c = 1;
const c = 2; // 에러 발생 (SyntaxError)
</code></pre>
<h3>스코프(Scope)</h3>
<ul>
<li>var은 함수 스코프를 가지며, 함수 안에서 선언되면 외부에서 접근할 수 없다.</li>
<li>let과 const는 블록 스코프를 가지며, {} 안에서만 유효하다.</li>
</ul>
<pre><code class="language-js">function test() {
    if (true) {
        var x = 10;
        let y = 20;
    }
    console.log(x); // 10 (함수 스코프)
    console.log(y); // 에러 (블록 스코프)
}
</code></pre>
<h3>호이스팅(Hoisting)</h3>
<ul>
<li>var은 선언과 동시에 undefined로 초기화됩니다.</li>
<li>let과 const는 선언만 되고 초기화되지 않아서 접근하면 에러가 발생합니다.</li>
</ul>
<pre><code class="language-js">console.log(a); // undefined
var a = 10;

console.log(b); // 에러 (Cannot access 'b' before initialization)
let b = 20;
</code></pre>
<h1>2. 브라우저는 어떻게 동작하는가</h1>
<h2>(0) 브라우저란</h2>
<p>브라우저란, 웹 페이지, 이미지, 비디오 등의 콘텐츠를 수신, 전송 및 표현하는 소프트웨어입니다.
(인터넷에 접속하기 위해 사용하는 Chrome, Safari, Edge, Firefox 등)</p>
<h2>(1) 브라우저의 구조</h2>
<ul>
<li><strong>사용자 인터페이스</strong> (UI): 주소창, 뒤로 가기, 새로고침 등의 요소
<ul>
<li>주소 표시줄, 각종 버튼(이전/다음, 새로고침, 설정, 닫기 등), 북마크 메뉴 등.</li>
<li>요청한 페이지를 보여주는 영역을 제외한 나머지 모든 부분이 사용자 인터페이스에 해당합니다.</li>
</ul>
</li>
<li>브라우저 엔진:
<ul>
<li>사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어해주는 엔진입니다.</li>
<li>자료 저장소를 참조하며 로컬에 데이터를 읽기/쓰기 하면서 다양한 작업을 합니다.</li>
</ul>
</li>
<li><strong>렌더링 엔진</strong>: HTML, CSS를 화면에 표시하는 역할 (ex. 크롬의 Blink)
<ul>
<li>요청한 콘텐츠를 표시합니다.</li>
<li>요청한 웹 페이지의 HTML과 CSS를 파싱하여 화면에 표시합니다.</li>
</ul>
</li>
<li><strong>자바스크립트 엔진</strong>: 자바스크립트 실행 (ex. Chrome V8)</li>
<li><strong>네트워크 모듈</strong>: HTTP 요청 및 응답 처리
<ul>
<li>HTTP 요청과 같은 네트워크 호출에 사용됩니다.</li>
</ul>
</li>
<li><strong>데이터 저장소</strong>: 쿠키, 로컬스토리지, 세션스토리지 등
<ul>
<li>쿠키, 로컬 스토리지와 같이 로컬 영역에 저장해야 하는 모든 종류의 데이터들을 저장합니다.</li>
</ul>
</li>
<li>자바스크립트 해석기:
<ul>
<li>자바스크립트 코드를 해석하고 실행합니다.</li>
</ul>
</li>
<li>UI 백엔드:
<ul>
<li>input, select 와 같이 기본적으로 지원하는 요소를 그립니다.</li>
<li>OS 사용자 인터페이스에서 정해준 것들을 사용합니다.</li>
</ul>
</li>
</ul>
<h2>(2) 브라우저의 동작 과정</h2>
<h3>1) 통신 과정</h3>
<ol>
<li>URL 입력 → 사용자가 주소창에 https://example.com 입력</li>
<li>DNS 조회 → example.com의 실제 IP 주소를 찾음</li>
<li>서버 요청 → IP 주소로 해당 웹사이트의 HTML을 요청 (HTTP GET request)
<ul>
<li>TCP 핸드쉐이크를 통해 연결을 설정. (보안성 있는 연결을 위해서는 TLS 협상도 필요)</li>
</ul>
</li>
<li>응답 받기 → 서버가 HTML, CSS, JavaScript 등을 응답으로 보냄</li>
</ol>
<h3>2) 렌더링 과정</h3>
<ol>
<li><strong>DOM</strong>, <strong>CSSOM</strong> 생성
<ul>
<li>DOM: Document Object Model</li>
<li>CSSOM: CSS Object Model</li>
<li>서버로부터 받은 HTML, CSS를 Parser를 통해 텍스트에서 Object Model로 만든다. (HTML→ DOM Tree, CSS→ CSSOM)</li>
</ul>
</li>
<li><strong>Render Tree</strong> 생성
<ul>
<li>Render Tree에는 스타일 정보가 설정되어 있음</li>
<li>실제 화면에 표현되는 노드들로 구성</li>
</ul>
</li>
<li><strong>Layout</strong>
<ul>
<li>Render Tree 노드들이 가지고 있는 스타일과 속성에 따라서 브라우저 화면의 어느 위치에 어떤 크기로 출력할지 계산하는 과정</li>
</ul>
</li>
<li><strong>Paint</strong>
<ul>
<li>Layout 계산에 따라 요소들을 실제 화면에 그리는 과정</li>
<li>이전 단계에서 요소들의 위치와 크기, 스타일 계산이 완료된 Render Tree를 이용해 실제 값을 채워 넣습니다. 이 때 텍스트, 색, 이미지, 그림자 효과 등을 모두 처리해 그립니다.</li>
</ul>
</li>
</ol>
<h1>3. 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임</h1>
<h2>이벤트 버블링</h2>
<ul>
<li>자식 요소에서 부모 요소로 이벤트가 전파되는 것</li>
<li>이를 막으려면 이벤트 객체에서 <code>stopPropagation</code> 메소드로 전파를 막을 수 있다.</li>
</ul>
<h2>이벤트 캡쳐링</h2>
<ul>
<li>부모 요소에서 자식 요소로 이벤트가 전파되는 것</li>
<li>캡쳐링 단계에서 이벤트 핸들러를 동작시키려면, <code>addEventListener</code> 에 세번째 프로퍼티에 <code>true</code> 또는 <code>{ capture: true }</code> 를 전달하면 된다.</li>
</ul>
<h2>이벤트 위임</h2>
<ul>
<li>자식 요소 각각에 이벤트 핸들러를 하나씩 등록할 필요 없이 부모 요소에서 한 번에 자식 요소들에 발생한 이벤트를 관리하는 방식</li>
</ul>
<h1>정리</h1>
<ul>
<li>var, let, const → 선언 방식의 차이 (스코프, 중복 선언, 호이스팅)</li>
<li>브라우저 동작 원리 → HTML → CSS → JS → 렌더링 과정
<ul>
<li>렌더링: HTML 파싱 → DOM 생성</li>
<li>CSS 파싱 → 스타일을 적용하여 렌더 트리(Render Tree) 생성</li>
<li>자바스크립트 실행 → 페이지 동적 조작</li>
<li>레이아웃 계산 &#x26; 페인트(Paint) → 최종 화면 출력</li>
</ul>
</li>
<li>이벤트 전파
<ul>
<li>이벤트 전파 흐름: 캡처링 → 타깃 → 버블링</li>
<li>이벤트 버블링: 자식 → 부모, <code>e.stopPropagation()</code>로 방지</li>
<li>이벤트 캡처링: 부모 → 자식</li>
<li>이벤트 위임: 부모 → 자식 요소 발생 이벤트 관리</li>
</ul>
</li>
</ul>
0:{"buildId":"NBOTbsJWgipKuL85VBogm","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
