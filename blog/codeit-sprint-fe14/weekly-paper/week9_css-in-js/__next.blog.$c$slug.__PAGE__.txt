1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T1c66,<h1>CSS-in-JS</h1>
<h2>개념 및 정의</h2>
<ul>
<li>Javascript 안에서 CSS 스타일을 작성하고 관리할 수 있는 기법</li>
<li>React, Vue, Angular 등 컴포넌트 기반 프레임워크에서 컴포넌트 단위로 스타일을 관리하기 위해 도입됨</li>
<li>Javascript 변수와 로직을 활용하여 동적 스타일링 가능</li>
</ul>
<h2>특징 및 동작 방식</h2>
<ul>
<li>컴포넌트 단위로 스타일을 캡슐화하여 전역 스타일 충돌을 방지</li>
<li>Javascript의 모듈 시스템을 사용하여 스타일을 공유하고 재사용할 수 있음</li>
<li>동적 스타일링과 조건부 스타일링 용이</li>
<li>JSX 문법과 함께 사용하여 직관적으로 스타일을 관리할 수 있음</li>
</ul>
<h2>예시</h2>
<h3>0. 주요 CSS-in-JS 라이브러리</h3>
<ul>
<li>Styled Components</li>
<li>Emotion</li>
<li>JSS (Javascript Style Sheets)</li>
<li>Styled JSX (Next.js 전용)</li>
<li>Linaria, Panda, VanillaExtract, StyleX... (Zero-runtime CSS-in-JS)</li>
</ul>
<h3>1. Styled Components</h3>
<pre><code class="language-js">import styled from "styled-components";

const Button = styled.button`
  background-color: ${(props) => (props.primary ? "blue" : "gray")};
  color: white;
  padding: 10px;
  border: none;
  border-radius: 5px;
  cursor: pointer;

  &#x26;:hover {
    background-color: ${(props) => (props.primary ? "darkblue" : "darkgray")};
  }
`;

const App = () => {
  return (
    &#x3C;div>
      &#x3C;Button primary>Primary Button&#x3C;/Button>
      &#x3C;Button>Secondary Button&#x3C;/Button>
    &#x3C;/div>
  );
};
export default App;
</code></pre>
<h3>2. Emotion</h3>
<pre><code class="language-js">/** @jsxImportSource @emotion/react */
import { css } from "@emotion/react";

const buttonStyle = (primary) => css`
  background-color: ${primary ? "blue" : "gray"};
  color: white;
  padding: 10px;
  border: none;
  border-radius: 5px;
  cursor: pointer;

  &#x26;:hover {
    background-color: ${primary ? "darkblue" : "darkgray"};
  }
`;

const App = () => {
  return (
    &#x3C;div>
      &#x3C;button css={buttonStyle(true)}>Primary Button&#x3C;/button>
      &#x3C;button css={buttonStyle(false)}>Secondary Button&#x3C;/button>
    &#x3C;/div>
  );
};
export default App;
</code></pre>
<h2>장점</h2>
<h3>1. 컴포넌트 단위 캡슐화</h3>
<ul>
<li>컴포넌트 단위로 스타일이 분리되어 <strong>스타일 유지보수 용이</strong>하다.</li>
<li>스타일이 컴포넌트 내부에 존재하므로, 전역 스타일 충돌이 없다.</li>
<li>컴포넌트의 재사용성과 유지보수성이 높다.</li>
<li>고유한 class명을 생성하여 전역 네임스페이스 오염을 방지한다. (Styled Components)</li>
</ul>
<h3>2. 동적 스타일링</h3>
<ul>
<li>props를 활용하여 <strong>동적으로 스타일을 변경</strong> 가능하다.</li>
<li>Javascript의 조건문, 함수 등을 사용하여 복잡한 스타일도 구현할 수 있다.</li>
</ul>
<h3>3. 모듈화 및 재사용</h3>
<ul>
<li>스타일을 모듈화하고 공유하여 코드 중복을 줄일 수 있다.</li>
<li>공통 스타일을 유틸리티 함수로 관리하여 유지보수가 용이하다.</li>
</ul>
<h3>4. React/JSX 문법과의 호환성</h3>
<ul>
<li>JSX와 함께 사용하여 직관적으로 스타일을 작성할 수 있다.</li>
<li>스타일과 로직을 한곳에서 관리하여 가독성이 높아진다.</li>
</ul>
<h2>단점</h2>
<h3>1. 런타임 성능 저하</h3>
<ul>
<li>런타임에 스타일을 생성하고 주입하기 때문에 렌더링 성능이 저하될 수 있다.</li>
<li>특히 대규모 애플리케이션에서 렌더링 성능에 영향을 미칠 수 있다.</li>
</ul>
<h3>2. 복잡한 설정</h3>
<ul>
<li>SSR(Server-Side Rendering)을 지원하기 위해 설정이 복잡할 수 있다.</li>
<li>Next.js등 SSR 프레임워크와 연동 시 설정 작업이 필요하다.</li>
</ul>
<h3>3. 빌드 사이즈 증가</h3>
<ul>
<li>CSS가 JS에 포함되므로, 번들 크기가 증가할 수 있다.</li>
<li>스타일 캐싱이 어려워 네트워크 비용이 증가할 수 있다.</li>
</ul>
<h3>4. 도구 및 라이브러리 의존성</h3>
<ul>
<li>Emotion, Styled Components 등 라이브러리 의존성이 추가된다.</li>
<li>팀 내에서 통일된 스타일링 규칙을 정의해야 일관성을 유지할 수 있다.</li>
</ul>
<h1>Presentational &#x26; Container 디자인 패턴</h1>
<h2>개념 및 정의</h2>
<h3>1. Presentational Component</h3>
<ul>
<li>UI 렌더링에만 집중하는 컴포넌트로, 스타일링과 마크업만 포함하고 상태관리나 비즈니스 로직이 없다.</li>
<li>props를 받아서 화면에 표시하고, 이벤트가 발생하면 콜백 함수만 호출한다.</li>
<li>재사용성이 높고 디자인을 쉽게 변경할 수 있다.</li>
</ul>
<pre><code class="language-jsx">const Button = ({ text, onClick }) => {
  return &#x3C;button onClick={onClick}>{text}&#x3C;/button>;
};
</code></pre>
<h3>2. Container Component</h3>
<ul>
<li>상태관리 및 비즈니스 로직을 담당하는 컴포넌트로, 데이터를 조회 및 가공하여 Presentational Component에 전달한다.</li>
<li>Redux, Context API, API 호출 등의 상태 관리 및 로직 처리를 수행한다.</li>
<li>UI 로직을 분리하여 유지보수성과 테스트가 용이하다.</li>
</ul>
<h2>역할 및 특징</h2>
<p>| <strong>구분</strong>          | <strong>Presentational Component</strong>             | <strong>Container Component</strong>                           |
| ----------------- | ---------------------------------------- | ------------------------------------------------- |
| <strong>역할</strong>          | UI 렌더링                                | 상태관리 및 비즈니스 로직 담당                    |
| <strong>관심사 분리</strong>   | 디자인 및 스타일링                       | 데이터 처리 및 비스니스 로직                      |
| <strong>상태 관리</strong>     | 없음 (stateless)                         | 있음 (statefull)                                  |
| <strong>데이터 소스</strong>   | props를 통해 데이터를 받음               | Redux, Context API, API 호출 등 데이터 관리 |
| <strong>재사용성</strong>      | 높음 (다양한 컨테이너와 조합 가능) | 낮음 (특정 기능에 의존적)                   |
| <strong>의존성</strong>        | 독립적                                   | Presentational Component에 족송적                 |
| <strong>테스트 용이성</strong> | 높음 (UI 스냅샷 테스트)            | 보통 (로직 테스트 필요)                     |</p>
<h2>사용 이유 및 장점</h2>
<ul>
<li>관심사의 분리: UI 렌더링과 비즈니스 로직을 분리하여 가독성 및 유지보수성이 높아진다.</li>
<li>재사용성 증가: Presentational Component는 다양한 컨테이너에서 재사용 가능하다.</li>
<li>디자인 변경에 유연: UI와 비즈니스 로직이 분리되어 디자인 변경 시 영향을 최소화할 수 있다.</li>
<li>테스트 용이성: UI와 비즈니스 로직이 분리되어 스냅샷 테스트와 로직 테스트 각각 집중할 수 있다.</li>
</ul>
0:{"buildId":"zkizE9bspPalFbAzzM_bK","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
