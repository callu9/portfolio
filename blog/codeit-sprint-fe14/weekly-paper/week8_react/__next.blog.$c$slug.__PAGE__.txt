1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T16c9,<h1>리액트 생명주기</h1>
<h2>리액트 생명주기(Lifecycle)란?</h2>
<ul>
<li>리액트 컴포넌트는 생성, 업데이트, 소멸까지 특정한 생명주기(Lifecycle)를 가진다.
<ul>
<li>클래스형 컴포넌트는 생명주기 메서드 사용해 관리 (<code>componentDidMount</code>, <code>componentDidUpdate</code> 등)</li>
<li>함수형 컴포넌트는 <code>useEffect</code>를 활용해 관리</li>
</ul>
</li>
</ul>
<h2>리액트 생명주기의 주요 단계</h2>
<p>| 단계 | 설명 | 주요 메서드/훅 |
| --- | --- | --- |
| Mounting (마운트) | 컴포넌트가 처음 생성될 때 | <code>componentDidMount</code>, <code>useEffect(() => {}, [])</code> |
| Updating (업데이트) | 상태(state) 또는 props가 변경될 때 | <code>componentDidUpdate</code>, <code>useEffect(() => {}, [deps])</code> |
| Unmounting (언마운트) | 컴포넌트가 제거될 때 | <code>componentWillUnmount</code>, <code>useEffect(() => { return () => {...} }, [])</code> |</p>
<h2>함수형 컴포넌트에서 생명주기 관리 (<code>useEffect</code> 활용)</h2>
<ol>
<li>마운트 시 API 호출</li>
</ol>
<pre><code class="language-js">import { useEffect } from 'react';

function Example() {
  useEffect(() => {
    console.log("컴포넌트가 마운트!")
    return () => {
      console.log("컴포넌트가 언마운트!")
    }
  }, []); // 빈 배열 → 최초 1회 실행

  return &#x3C;div>Example Component&#x3C;/div>
}
</code></pre>
<ol start="2">
<li>업데이트 시 실행 (의존성 배열 활용)</li>
</ol>
<pre><code class="language-js">useEffect(() => {
  console.log("count 값이 변경됨: ", count);
}, [count]); // count 값이 변경될 때 실행
</code></pre>
<ol start="3">
<li>언마운트 시 정리 작업 (이벤트 리스너 제거 등)</li>
</ol>
<pre><code class="language-js">useEffect(() => {
  const handleResize = () => console.log(window.innerWidth);
  window.addEventListener("resize", handleResize);
  return ()  => {
    window.removeEventListener("resize", handleResize); // 정리 (clean-up)
  }
}, []);
</code></pre>
<h2>리액트 생명주기의 활용 예시</h2>
<p>| 기능 | 생명주기 단계 | 사용 예시 |
| --- | --- | --- |
| API 데이터 가져오기 | <code>componentDidMount</code>, <code>useEffect(() => {}, [])</code> | 초기 데이터 로딩 |
| 상태 변화 감지 | <code>componentDidUpdate</code>, <code>useEffect(() => {}, [deps])</code> | 특정 값이 변경될 때 실행 |
| 이벤트 리스너 정리 | <code>componentWillUnmount</code>, <code>useEffect(() => { return () => {...} }, [])</code> | 컴포넌트 제거 시 이벤트 해제 |</p>
<h1>웹페이지 렌더링 방식 (CSR, SSR, SSG)</h1>
<h2>CSR (Client-Side Rendering)</h2>
<p>CSR (Client-Side Rendering, 클라이언트 사이드 렌더링)</p>
<ul>
<li>설명: HTML을 먼저 로드한 후, 브라우저에서 JavaScript를 실행하여 데이터를 가져와 화면을 동적으로 생성하는 방식</li>
<li>특징:
<ul>
<li>초기 로딩 속도가 느림 (Javascript 실행 후 렌더링 됨)</li>
<li>이후 페이지 전환이 빠른 (SPA 방식)</li>
<li>검색 엔진(SEO) 최적화가 어려움 (초기 HTML이 비어 있음)</li>
</ul>
</li>
<li>사용 예시:
<ul>
<li>React, Vue 기반의 SPA (Single Page Application)</li>
<li>대화형 웹 애플리케이션 (ex. Gmail, Facebook)</li>
</ul>
</li>
</ul>
<h2>SSR (Server-Side Rendering)</h2>
<p>SSR (Server-Side Rendering, 서버 사이드 렌더링)</p>
<ul>
<li>설명: 서버에서 미리 HTML을 생성하여 클라이언트에게 전달하는 방식</li>
<li>특징:
<ul>
<li>초기 로딩 속도가 빠름 (완전한 HTML이 제공됨)</li>
<li>SEO 친화적 (검색 엔진이 HTML을 쉽게 읽을 수 있음)</li>
<li>페이지 이동 시마다 서버 요청이 필요하므로, 사용자가 많아지면 서버 부하 발생</li>
</ul>
</li>
<li>사용 예시:
<ul>
<li>SEO가 중요한 블로그, 뉴스 사이트 (ex. Medium, New York Times)</li>
<li>Next.js (React 기반 SSR 프레임 워크)</li>
</ul>
</li>
</ul>
<h2>SSG (Static Site Generation)</h2>
<p>SSG (Static Site Generation, 정적 사이트 생성)</p>
<ul>
<li>설명: 빌드 시점에 HTML을 미리 생성하여 배포하는 방식</li>
<li>특징:
<ul>
<li>초기 로딩 속도가 가장 빠름 (미리 생성된 HTML 제공)</li>
<li>SEO 친화적 (HTML이 정적으로 제공됨)</li>
<li>데이터가 자주 변경되지 않는 페이지에 적합</li>
<li>실시간 데이터 반영이 어려움 (빌드 후 다시 배포해야 함)</li>
</ul>
</li>
<li>사용 예시:
<ul>
<li>블로그, 문서 사이트 (ex. GitHub Pages)</li>
<li>Next.js의 <code>getStaticProps()</code> 활용</li>
</ul>
</li>
</ul>
<h2>비교</h2>
<p>| 방식 | 초기 로딩 속도 | SEO 최적화 | 페이지 전환 속도 | 서버 부하 |
| --- | --- | --- | --- | --- |
| <strong>CSR</strong> | 느림 | 어렵다 | 빠름 | 낮음 |
| <strong>SSR</strong> | 빠름 | 좋음 | 느림 | 높음 |
| <strong>SSG</strong> | 가장 빠름 | 좋음 | 가장 빠름 | 없음 |</p>
<h2>사용 예시</h2>
<p>| 상황 | 적합한 렌더링 방식 |
| --- | --- |
| SPA (싱글 페이지 애플리케이션) | CSR |
| 검색 엔진 최적화 (SEO) 필요 | SSR or SSG |
| 블로그, 문서 사이트 (변경이 적은 정적 페이지) | SSG |
| 사용자 맞품 데이터가 많은 서비스 | SSR (로그인 정보에 따라 다르게 렌더링) |</p>
<h2>정리</h2>
<ul>
<li>CSR: SPA에서 사용자 경험(UX) 중요한 경우 사용</li>
<li>SSR: SEO가 중요하거나, 사용자 맞춤 데이터를 즉시 반영해야 할 때 사용</li>
<li>SSG: 데이터 변경이 적고 빠른 페이지 로딩이 중요한 경우 사용</li>
</ul>
<p>Next.js 같은 프레임워크는 CSR, SSR, SSG를 혼합하여 사용할 수 있음</p>
0:{"buildId":"NBOTbsJWgipKuL85VBogm","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
