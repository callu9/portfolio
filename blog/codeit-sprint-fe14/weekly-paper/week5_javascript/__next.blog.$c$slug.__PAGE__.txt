1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T1a96,<h1>1. this</h1>
<h2>this 키워드</h2>
<ul>
<li>설명: 현재 실행 중인 컨텍스트(문맥, 환경)에 따라 다르게 동작하는 키워드입니다.</li>
<li>동작 방식
<ol>
<li>
<p>일반 함수에서 this: <strong>전역 객체</strong>(window)를 가리킴
(use strict에서는 undefined)</p>
<pre><code class="language-js">function show() {
    console.log(this); // window (브라우저 환경)
}
show();
</code></pre>
</li>
<li>
<p>객체의 메서드에서 this: 해당 객체를 가리킴</p>
<pre><code class="language-js">const obj = {
    name: "Alice",
    show: function () {
        console.log(this.name); // "Alice"
    }
};
obj.show();
</code></pre>
</li>
<li>
<p>화살표 함수에서 this: 화살표 함수는 this를 부모 스코프에서 가져옴</p>
<pre><code class="language-js">const obj = {
    name: "Alice",
    show: () => {
        console.log(this.name); // undefined (부모 스코프가 window)
    }
};
obj.show();
</code></pre>
</li>
<li>
<p>생성자 함수에서 this: 새로 생성된 객체를 가리킴</p>
<pre><code class="language-js">function Person(name) {
    this.name = name;
}
const user = new Person("Alice");
console.log(user.name); // "Alice"
</code></pre>
</li>
<li>
<p>이벤트 핸들러에서 this: 이벤트를 발생시킨 요소를 가리킴</p>
<pre><code class="language-js">document.querySelector("button").addEventListener("click", function() {
    console.log(this); // 클릭된 버튼 요소
});
</code></pre>
</li>
<li>
<p>bind 메소드에서 this: 첫 번째 파라미터로 전달한 특정 객체에 명시적으로 바인딩 됨</p>
<pre><code class="language-js">function returnThis() {
    return this;
}

const obj = { name: 'obj' };
const obj2 = returnThis.bind(obj)();

console.log(obj === obj2); // true
</code></pre>
</li>
</ol>
</li>
</ul>
<h1>2. 렉시컬 스코프</h1>
<ul>
<li>스코프: <strong>식별자</strong> 접근 규칙에 따른 <strong>유효 범위</strong>를 뜻한다.
<ul>
<li>식별자: 변수, 함수 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름</li>
</ul>
</li>
<li>렉시컬 스코프(Lexical scope): 식별자 <strong>유효 범위</strong>가 함수를 호출할 때 결정되는 것이 아닌, <strong>선언</strong>할 때 <strong>결정</strong>되는 것을 뜻한다. 정적 스코프(Static scope)라고도 불리며, 자바스크립트는 렉시컬 스코프를 따른다.</li>
</ul>
<pre><code class="language-js">var x = 'foo';

function foo() {
    var x = 'bar';
    bar();
}

function bar() {
    console.log(x);
}

foo(); // foo
bar(); // foo
</code></pre>
<h1>3. 프로토타입 체인</h1>
<h2>프로토타입이란</h2>
<ul>
<li>프로토타입(Prototype)은 원형이라는 의미를 가진 단어</li>
<li>자바스크립트에서 프로토타입은 객체의 원형</li>
<li>모든 객체들은 메소드와 속성을 상속 받기 위해 프로토타입 객체를 가진다.</li>
<li>즉, 프로토타입 객체란 자신의 부모 역할을 하는 객체를 말한다.</li>
</ul>
<h2><code>[[Prototype]]</code> , <code>.__proto__</code> , <code>.prototype</code> 알아보기</h2>
<ol>
<li><code>[[Prototype]]</code></li>
</ol>
<p>개발자가 직접 접근이 불가하고 간접적으로 접근할 수 있는 내부 슬롯으로, 직접 접근을 불가하게 해서 프로토타입 체인의 방향을 자식에서 부모를 탐색하는 단방향으로 지키고, 개발자의 실수로 순환참조하는 일이 없도록 한다.</p>
<ul>
<li>내부 슬롯이란?자바스크립트 엔진의 구현된 내용을 설명하기 위한 pseudo 프로퍼티</li>
</ul>
<pre><code class="language-js">function Person(name) {
    this.name = name;
}

console.dir(Person);
</code></pre>
<ol start="2">
<li><code>__proto__</code></li>
</ol>
<p>객체의 프로토타입(<code>[[Prototype]]</code>)을 접근하기 위한 프로퍼티로, 자신의 프로토타입에 접근할 수 있으며, <code>Object.getPrototypeOf()</code> 와 동일한 기능을 수행한다.</p>
<pre><code class="language-js">function Person(name) {
    this.name = name;
}

console.log(Person.__proto__ === Object.getPrototypeOf(Person)); // true
</code></pre>
<ol start="3">
<li><code>prototype</code> 프로퍼티</li>
</ol>
<p>생성자 함수로 호출할 수 있는 객체, 즉 constructor 를 소유하는 프로퍼티.</p>
<p>일반 객체와 생성자 함수로 호출할 수 없는 arrow function은 prototype 프로퍼티가 없다.</p>
<pre><code class="language-js">function Person(name) {
    this.name = name;
}

// foo 객체를 생성한 객체는 Person() 생성자 함수
const foo = new Person('코드잇');

console.log(foo.__proto__ === Person.prototype); // true
console.log(Person.prototype) // {constructor: f}
</code></pre>
<h2>프로토타입 체인</h2>
<p>프로토타입 체인은 프로토타입 간의 연결이며, 이를 통해 상위 프로토타입을 검색할 수 있다. 해당 객체에 접근하려는 프로퍼티나 메소드가 없다면 프로토타입(<code>[[Prototype]]</code>)이 가리키는 링크, 즉 프로토타입 체인을 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다.</p>
<p>모든 객체의 최상위 프로토타입은 <code>Object.prototype</code>다.</p>
<pre><code class="language-js">function Person(name) {
    this.name = name;
}

const foo = new Person('코드잇');
const string = 'abc';
const number = 123;
const array = [1,2,3];
const arrowFunction = () => 'arrowFunction';
const object = {a: 'abc'};

console.log(foo.__proto__ === Person.prototype); // true
console.log(string.__proto__ === String.prototype); // true
console.log(number.__proto__ === Number.prototype); // true
console.log(array.__proto__ === Array.prototype); // true
console.log(arrowFunction.__proto__ === Function.prototype); // true

console.log(foo.__proto__.__proto__ === Object.prototype); // true
console.log(string.__proto__.__proto__ === Object.prototype); // true
console.log(number.__proto__.__proto__ === Object.prototype); // true
console.log(array.__proto__.__proto__ === Object.prototype); // true
console.log(arrowFunction.__proto__.__proto__ === Object.prototype); // true
console.log(object.__proto__ === Object.prototype); // true
</code></pre>
<h1>정리</h1>
<ul>
<li>this가 가리키는 값, 즉 this 바인딩은 실행 컨텍스트에 따라 달라진다.</li>
<li>렉시컬 스코프란, 식별자 유효 범위가 함수를 선언할 때 결정된다는 것을 의미한다.</li>
<li>프로토타입 체인이란, 객체의 상위 프로토타입과의 연결을 의미하며, 이를 통해 상위 프로토타입의 프로퍼티 혹은 메소드에 접근할 수 있다.</li>
</ul>
0:{"buildId":"NBOTbsJWgipKuL85VBogm","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
