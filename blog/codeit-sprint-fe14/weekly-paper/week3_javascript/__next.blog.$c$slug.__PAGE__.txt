1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T207e,<h1>1. <code>==</code>와 <code>===</code>의 차이</h1>
<p>자바스크립트에서 <code>==</code>와 <code>===</code>는 비교 연산자로, 두 값을 비교할 때 사용되지만, 비교 방식에서 큰 차이가 있다.</p>
<h2><code>==</code> (동등 연산자)</h2>
<ul>
<li>설명: 두 값을 비교할 때, 타입을 자동으로 변환(type coercion) 한 후 값을 비교합니다.</li>
<li>특징:
<ul>
<li>타입이 다르면, 자바스크립트가 자동으로 타입을 일치시킨 후 비교합니다.</li>
<li>타입 변환으로 인해 예상치 못한 결과가 나올 수 있습니다.</li>
</ul>
</li>
<li>예시:
<pre><code class="language-js">console.log(1 == '1');   // true (숫자와 문자열을 같은 값으로 간주)
console.log(true == 1);  // true (불리언을 숫자로 변환)
console.log(null == undefined); // true (특별 케이스)
</code></pre>
</li>
</ul>
<h2><code>===</code> (일치 연산자)</h2>
<ul>
<li>설명: 두 값을 비교할 때, 타입까지 엄격하게 비교합니다.</li>
<li>특징:
<ul>
<li>타입 변환이 일어나지 않습니다.</li>
<li>값 뿐만 아니라 타입까지 일치해야 true를 반환합니다.</li>
</ul>
</li>
<li>예시:
<pre><code class="language-js">console.log(1 === '1');   // false (타입이 다름)
console.log(true === 1);  // false (타입이 다름)
console.log(null === undefined); // false (타입이 다름)
</code></pre>
</li>
</ul>
<h2>차이 요약</h2>
<p>| 연산자   | 타입 변환     | 비교 조건                         | 비유             |
| ----- | --------- | ----------------------------- | -------------- |
| <code>==</code>  | O | 값만 같으면 true(느슨한 비교)       | “둘이 비슷하면 OK!”  |
| <code>===</code> | X         | 값과 타입 모두 같아야 true(엄격한 비교) | “완전히 똑같아야 OK!” |</p>
<h2>관련 내용</h2>
<ul>
<li><code>==</code> 는 암묵적 형변환이이 일어나는데, 암묵적 형변환이 일어날 것을 모두 기억하거나 예측하는 것이 어렵기 때문에, 의도하지 않은 결과를 얻게 될 가능성이 크고 이로 인해 오류 가능성이 커집니다. 따라서 동등함을 비교하기 위해서 <code>===</code> 를 사용하는 것이 좋습니다.</li>
<li>비교 연산 중에 ES6(ECMAScript 2015)에 추가된 Object.is 도 있습니다. +0, 0, NaN, 비교 이외에는 <code>===</code> 연산과 동일한 결과를 줍니다.</li>
<li>객체간 비교할 경우 객체 안의 내용이 같더라도 참조형이기 때문에 <code>==</code>, <code>===</code>, <code>Object.is</code> 로 비교하면 false로 판단합니다. 따라서 <code>JSON.stringify</code> 로 객체 안의 내용을 문자열로 변환한 후 비교 하거나 순서가 보장되지 않는 값이라면, 정렬 후 비교 합니다.</li>
</ul>
<h3>참고</h3>
<p>https://developer.mozilla.org/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness</p>
<h1>2. 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)</h1>
<h2>자바스크립트 자료형</h2>
<p>자바스크립트에서 값을 복사할 때, 자료형에 따라 복사하는 값이 달라집니다.</p>
<ul>
<li>기본형(Primitive type): Number, String, Boolean, Null, Undefined, Symbol
<ul>
<li>데이터 변경이 불가(immutable)합니다.</li>
<li>변수에 기본형을 할당하면 새로운 메모리 공간에 독립적인 <strong>실제값이 복사</strong>됩니다.</li>
</ul>
<pre><code class="language-js">let x = 1;
let y = x;

x = 123

console.log(x) // 123을 출력
console.log(y) // 1을 출력 (y에 할당되었던 1이 변경되지 않음)
</code></pre>
</li>
<li>참조형(Reference type): Object(Array, Function, Map 등 기본형을 제외한 모든 것)
<ul>
<li>데이터의 내용 변경이 가능(mutable)합니다.</li>
<li>변수에 참조형을 할당하면 해당 <strong>객체의 메모리 주소값이 복사</strong>됩니다.</li>
</ul>
<pre><code class="language-js">let obj1 = {num: 1};
let obj2 = obj1;

obj1.num = 123

console.log(obj1) // {num: 123}을 출력
console.log(obj2) // {num: 123}을 출력 (obj2에 할당되었던 {num: 1}의 내용이 obj1을 따라 변경)

// obj2 가 obj1 객체의 메모리 주소값을 복사하기 때문에, 
// obj1 의 값이 변경되면 obj2 도 동일한 메모리 주소에 있는 값을 가져 변경된 값을 갖게 됩니다.
</code></pre>
</li>
</ul>
<p>따라서, 얕은 복사와 깊은 복사는 객체 또는 배열을 복사할 때, 데이터 구조와 메모리의 다루는 방식에서 차이가 있다.</p>
<h2>얕은 복사 (Shallow Copy)</h2>
<ul>
<li>설명:
<ul>
<li>원본 객체의 1단계 속성만 복사합니다.</li>
<li>복사된 객체는 원본 객체와 참조 주소를 공유합니다. 즉, 중첩된 객체나 배열의 내용은 복사되지 않고, 같은 메모리를 가리킵니다.</li>
</ul>
</li>
<li>특징:
<ul>
<li>원본 객체가 변경되면, 복사본도 영향을 받을 수 있습니다.</li>
<li>성능이 빠르고 간단한 구조에서는 유용합니다.</li>
</ul>
</li>
<li>예시:
<pre><code class="language-js">const original = { name: "Alice", details: { age: 25 } };
const shallowCopy = { ...original }; // 얕은 복사

shallowCopy.details.age = 30;
console.log(original.details.age); // 30 (원본도 변경됨)
</code></pre>
</li>
</ul>
<h2>깊은 복사 (Deep Copy)</h2>
<ul>
<li>설명:
<ul>
<li>원본 객체의 모든 데이터를 재귀적으로 복사합니다.</li>
<li>복사된 객체는 원본 객체와 완전히 독립적이며, 중첩된 객체나 배열까지 새롭게 복사됩니다.</li>
</ul>
</li>
<li>특징:
<ul>
<li>원본 객체가 변경되어도, 복사본에는 영향을 주지 않습니다.</li>
<li>복사가 복잡하고 성능이 상대적으로 느립니다.</li>
</ul>
</li>
<li>예시:
<pre><code class="language-js">const original = { name: "Alice", details: { age: 25 } };

const deepCopy = JSON.parse(JSON.stringify(original)); // 깊은 복사
deepCopy.details.age = 30;

console.log(original.details.age); // 25 (원본은 영향받지 않음)
</code></pre>
</li>
</ul>
<h2>비교</h2>
<p>| 비교 항목                    | 복사 범위           | 참조 관계              | 성능  | 사용 예       | 비유                                      |
| ------------------------ | --------------- | ------------------ | --- | ---------- | --------------------------------------- |
| 얕은 복사 (Shallow Copy) | 1단계 속성만 복사      | 중첩된 객체는 원본과 참조를 공유 | 빠름  | 간단한 객체     | “겉모습만 복사하는 것.” (옷만 다른데 속은 같음)       |
| 깊은 복사 (Deep Copy)    | 중첩된 데이터까지 모두 복사 | 모든 데이터가 완전히 독립적    | 느림  | 중첩된 객체나 배열 | “완전히 새로운 사람을 만드는 것.” (겉과 속이 모두 독립적) |</p>
<h2>참조형의 깊은 복사</h2>
<ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>, <code>JSON.stringify()</code>
<ul>
<li>객체를 json 문자열로 변환하는데 이 과정에서 원본 객체와의 참조가 모두 끊어지고, 객체를 json 문자열로 변환 후, JSON.parse() 를 이용해 다시 원래 객체로 만들어 줍니다.</li>
<li>가장 간편하다는 장점이 있습니다.</li>
<li>function이 있는 경우 undefined 처리한다는 단점이 있습니다.</li>
<li>다른 방법에 비해 느리다는 단점이 있습니다.</li>
</ul>
</li>
<li>커스텀 재귀 함수를 활용한 복사
<ul>
<li>객체의 함수도 제대로 표현할 수 있습니다.</li>
<li>복잡하다는 단점이 있습니다.</li>
</ul>
</li>
<li>Lodash와 같은 외부 라이브러리 활용
<ul>
<li>외부 라이브러리 사용에 제약이 없다면 가장 효과적인 선택지가 될 수 있습니다.</li>
</ul>
</li>
</ul>
<h3>참고</h3>
<p>https://choar816.tistory.com/154</p>
<h3>추가 설명</h3>
<ul>
<li>얕은 복사 방법:
<ul>
<li><code>Object.assign()</code></li>
<li>Spread 연산자 <code>{ ...obj }</code></li>
</ul>
</li>
<li>깊은 복사 방법:
<ul>
<li><code>JSON.parse(JSON.stringify(obj))</code> (단, 함수나 undefined는 복사되지 않음)</li>
<li>외부 라이브러리 활용 (ex. Lodash의 cloneDeep)</li>
</ul>
</li>
</ul>
0:{"buildId":"zkizE9bspPalFbAzzM_bK","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
