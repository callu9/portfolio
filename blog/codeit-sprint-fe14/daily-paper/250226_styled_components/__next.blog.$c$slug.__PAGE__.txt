1:"$Sreact.fragment"
3:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
5:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
6:"$Sreact.suspense"
2:Td19,<h1>Styled Components</h1>
<h2>특징</h2>
<ul>
<li>CSS-in-JS 방식의 스타일링 라이브러리</li>
<li>Javascript 파일 내에서 CSS를 작성하고, 컴포넌트화하여 스타일과 로직을 하나의 파일에서 관리할 수 있다.</li>
<li>동적인 스타일링이 가능하며, props에 따라 스타일을 조정할 수 있다.</li>
<li>재사용성과 유지보수성이 높다.</li>
<li>컴포넌트 단위로 스타일이 적용되며, 중복되지 않는 고유한 클래스명이 자동 생성되어 CSS class 중복 문제나 전역 스타일 오염을 방지할 수 있다.</li>
<li><code>ThemeProvider</code> 사용 시 전체 애플리케이션에서 일관된 테마를 쉽게 관리할 수 있다.</li>
<li><code>keyframes</code> 사용하여 애니메이션과 미디어 쿼리의 직접 작성 및 사용이 가능하다.</li>
</ul>
<h2>기존 스타일링 방식과의 차이점</h2>
<p>| <strong>구분</strong>             | <strong>기존 방식 (CSS, Sass, CSS in Modules)</strong>               | <strong>Styled Components</strong>                                             |
| -------------------- | ------------------------------------------------------------- | ----------------------------------------------------------------- |
| <strong>스타일링 방식</strong>    | 분리된 CSS 파일 또는 CSS Modules 사용                         | CSS-in-JS (JS 내부에 CSS 작성)                                    |
| <strong>컴포넌트화</strong>       | className을 수동으로 관리,전역 스타일링                 | 컴포넌트 단위로 스타일 선언 및 적용                               |
| <strong>클래스 네이밍</strong>    | 수동 관리 (ex. class=”button-primary”)                  | 자동화된 고유 클래스명 생성(ex. Component__Button-abc123) |
| <strong>스타일 중복 문제</strong> | 전역 네임 스페이스 문제 발생 가능                             | Scoped Styling으로 중복 문제 방지                                 |
| <strong>동적 스타일링</strong>    | CSS 변수 또는 JS 코드와 혼합 사용 필요                        | props를 사용한 조건부 스타일링                                    |
| <strong>테마 관리</strong>        | 전역 변수 또는 상속 사용 (일관성 관리 어려움)           | ThemeProvider를 통해 전역 테마 일관성 유지                        |
| <strong>빌드 및 성능</strong>     | 전체 CSS 파일이 로드됨 (사용하지 않는 스타일 포함 가능) | CSS가 JS와 함께 번들링 (필요한 부분만 로드)                 |</p>
<h2>장점</h2>
<ul>
<li>컴포넌트 단위로 스타일 관리가 가능하여 유지보수가 편리</li>
<li>props를 사용한 동적 스타일링이 간편</li>
<li>고유한 클래스명 생성으로 이름 충돌 문제를 방지</li>
<li>ThemeProvider 통한 전역 테마 관리가 용이</li>
<li>React Native에서도 재사용 가능</li>
</ul>
<h2>단점</h2>
<ul>
<li>JS 파일 크기 증가로 인해 초기 로딩 속도 저하 가능성이 있음.</li>
<li>Next.js 등과 호환성 이슈가 있음</li>
<li>빌드 타임에 동적 스타일을 계산하기 때문에 복잡한 계산이 필요한 경우 성능 저하가 발생</li>
<li>기존 CSS/Sass와의 호환성이 낮음</li>
</ul>
0:{"buildId":"zkizE9bspPalFbAzzM_bK","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L3",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]]}]}]}],[["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]],"$L4"]}],"loading":null,"isPartial":false}
4:["$","$L5",null,{"children":["$","$6",null,{"name":"Next.MetadataOutlet","children":"$@7"}]}]
7:null
