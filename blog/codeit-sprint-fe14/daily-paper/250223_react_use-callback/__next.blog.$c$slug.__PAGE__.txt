1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T183f,<h1>useCallback</h1>
<ul>
<li>React Hook으로, <strong>함수를 메모이제이션</strong>하여 <strong>불필요한 함수 재생성을 방지</strong>하는 역할</li>
</ul>
<pre><code class="language-js">const memoizedCallback = useCallback(
  () => {
    console.log("Hello, World!");
  },
  [] // 의존성 배열
);
// 빈 배열을 의존성으로 가지므로, 컴포넌트가 리렌더링 되어도 함수가 재생성되지 않음.
</code></pre>
<h2>모던 자바스크립트 특성과의 연관성</h2>
<h3>1. 함수는 1급 객체 (First-Class Citizen)</h3>
<p>자바스크립트에서 함수는 1급 객체이다. 따라서</p>
<ul>
<li>변수에 할당할 수 있다.</li>
<li>다른 함수의 인자로 전달될 수 있다.</li>
<li>반환값으로도 사용할 수 있다.</li>
</ul>
<pre><code class="language-js">const func = () => console.log("Hello!");
const anotherFunc = func; // 함수 대입 가능
anotherFunc(); // Hello!
</code></pre>
<p>하지만 리액트에서는 <strong>리렌더링 시마다 새로운 함수가 재생성</strong>되므로 성능 문제가 발생할 수 있다.</p>
<pre><code class="language-js">const handleClick = () => console.log("Clicked!");

// useEffect에 handleClick을 넣었을 때
useEffect(() => {
  console.log("Effect runs!");
}, [handleClick]); // handleClick이 매번 새로 생성되어 useEffect가 계속 실행됨!
</code></pre>
<p>➡ useCallback을 사용하면 <strong>기존 함수 참조값을 유지</strong>하여, 위와 같은 <strong>불필요한 재실행을 방지</strong>할 수 있다.</p>
<h3>2. 클로저 (Closure)</h3>
<p>클로저란, <strong>내부 함수가 외부 함수의 스코프에 접근할 수 있는 기능</strong></p>
<pre><code class="language-js">function outer() {
  var count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}

const increment = outer();
increment(); // 1
increment(); // 2
</code></pre>
<p>➡ useCallback은 클로저를 활용하여 <strong>이전 상태의 변수를 유지</strong>하면서 <strong>참조값을 변경하지 않는다</strong>.</p>
<pre><code class="language-js">const handleClick = useCallback(() => {
  console.log("Clicked!");
}, []); // 빈 배열이므로 handleClick의 참조값이 변경되지 않음
</code></pre>
<ul>
<li>클로저 덕분에 useCallback 내부에서 이전 상태를 기억하고 있음</li>
<li>의존성 배열이 변경되지 않으면, 이전에 생성된 함수를 재사용함</li>
</ul>
<h3>3. 참조형 데이터 (Reference Type)</h3>
<p>자바스크립트의 객체, 배열, 함수 등은 참조형 데이터이므로, 메모리 주소(<strong>참조값</strong>)을 비교하여 변경 여부를 판단한다.</p>
<pre><code class="language-js">const a = () => {};
const b = () => {};

console.log(a === b); // false (새로운 함수가 생성되었기 때문)
</code></pre>
<p>➡ useCallback을 사용하면 함수가 새로 생성되지 않도록 <strong>참조값을 고정</strong>할 수 있다.</p>
<pre><code class="language-js">const memoizedFunction = useCallback(() => {}, []);
</code></pre>
<p>위처럼 useCallback이 기존의 함수 참조를 재사용하여 불필요한 메모리 낭비를 줄일 수 있다.</p>
<h2>useCallback의 사용 이유 (React 최적화)</h2>
<h3>1. 불필요한 리렌더링 방지 (React.memo)</h3>
<p>컴포넌트가 불필요하게 리렌더링 되는 것을 방지하기 위해 사용한다.</p>
<pre><code class="language-js">const ChildComponent = React.memo(({ onClick }) => {
  console.log("Child Rendered!");
  return &#x3C;button onClick={onClick}>Click me!&#x3C;/button>;
});
const Parent = () => {
  const handleClick = useCallback(() => {
    console.log("Button Clicked!");
  }, []);
  return &#x3C;ChildComponent onClick={handleClick} />;
};
</code></pre>
<p>위 예시에서 <code>handleClick</code>이 <code>useCallback</code>을 사용하여 <strong>항상 같은 참조값을 유지</strong>하기 때문에, <code>React.memo</code>가 적용된 <code>ChildComponent</code>는 불필요한 리렌더링을 방지할 수 있다.</p>
<h3>2. useEffect의 의존성 배열 최적화</h3>
<p>useEffect의 <strong>불필요한 재실행을 방지</strong>할 수 있다.</p>
<pre><code class="language-js">const fetchData = useCallback(() => {
  console.log("Fetching data...");
}, []);

useEffect(() => {
  fetchData();
}, [fetchData]); // useCallback이 없으면 fetchData가 계속 새로 생성된다.
</code></pre>
<p>위 예시에서 <code>useCallback</code>을 사용하여 <code>fetchData</code>의 <strong>참조값을 유지</strong>하면, <code>useEffect</code>가 불필요하게 <strong>다시 실행되는 것을 방지</strong>할 수 있다.</p>
<h2>정리</h2>
<p>| useCallback            | 모던 자바스크립트 특성과의 관계                                                                                                    |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| 함수 재생성 방지       | 자바스크립트의 <strong>1급 객체 특성</strong> 덕분에 함수가 변수처럼 다뤄지지만, 리렌더링 시 새로 생성되는데, 이때 useCallback은 이를 방지한다. |
| 참조값 유지            | <strong>참조형 데이터의 특성</strong> 덕분에 useCallback으로 기존 함수 참조를 재사용 가능하다.                                                  |
| 클로저 활용            | <strong>클로저</strong> 덕분에 기존 변수를 기억하면서도 참조값은 변경되지 않는다.                                                               |
| 불필요한 리렌더링 방지 | <code>React.memo</code>, <code>useEffect</code> 의존성 배열과 함께 사용하여 최적화 가능하다.                                                             |</p>
<p>➡ useCallback은 모던 자바스크립트의 <strong>클로저, 참조형 데이터, 1급 객체</strong> 개념을 활용하여 <strong>불필요한 함수 재생성을 방지</strong>하고 <strong>리액트 최적화</strong>에 도움을 준다.</p>
0:{"buildId":"NBOTbsJWgipKuL85VBogm","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
