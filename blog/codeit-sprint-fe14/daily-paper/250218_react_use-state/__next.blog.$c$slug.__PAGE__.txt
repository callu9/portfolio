1:"$Sreact.fragment"
3:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
4:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
5:"$Sreact.suspense"
2:T8c1,<h1>useState</h1>
<p>참고 - 코드잇 강의 리액트로 데이터 다루기:<a href="https://www.codeit.kr/topics/handling-data-with-react/lessons/5048">비동기로 state를 변경할 때 주의할 점</a></p>
<p><img src="./screenshot/react-use-state.png" alt="react-use-state"></p>
<p>Q. setState 함수에서 콜백을 사용하여 state를 업데이트하는 과정이 어떻게 되나요? (어떻게 리액트가 현재 시점의 state 값을 파라미터 prevItems로 넘겨줄 수 있는 건가요?)</p>
<h2>클로저(Closure)</h2>
<p>클로저란, 함수가 선언된 환경을 기억하는 구조를 일컫습니다. 예를 들어, <code>inner</code> 함수를 리턴하도록 선언된 <code>outer</code> 함수가 호출되어 메모리 상에서 사라지더라고, 해당 <code>outer</code> 함수가 선언된 환경을 기억하여 <code>a</code>라는 변수가 업데이트 됩니다.</p>
<pre><code class="language-js">function outer() {
  var a = 1;
  function inner() {
    a++;
    console.log(a);
  }
  return inner;
}

var closure = outer();
closure(); // 2
closure(); // 3
</code></pre>
<h3>useState의 간략한 과정</h3>
<p><code>useState</code>를 구현해보면 아래와 같습니다.</p>
<p>setState 함수는 전달된 파라미터의 타입 연산을 통해, 값이라면 파라미터 값으로 업데이트를 하고, 콜백 함수라면 콜백 함수에 현재 state를 전달하여 받은 결과값으로 업데이트를 합니다.</p>
<pre><code class="language-js">function useState(initialValue) {
  let state = initialValue;

  const getState = () => state; // state 값을 반환하는 함수

  const setState = (newValue) => {
    // state 값을 업데이트하는 함수
    state = typeof newValue === "function" ? newValue(state) : newValue;
    console.log("State updated:", state);
  };

  return [getState, setState]; // getter setter 함수 배열 반환
}

const [getCount1, setCount1] = useState(0);
const [getCount2, setCount2] = useState(10);

setCount1(1);
setCount2(20);

console.log(getCount1()); // 1
console.log(getCount2()); // 20

setCount1((prev) => prev + 1);
setCount2((prev) => prev + 10);

console.log(getCount1()); // 2
console.log(getCount2()); // 30
</code></pre>
0:{"buildId":"zkizE9bspPalFbAzzM_bK","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L3",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]]}]}]}],[["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]],["$","$L4",null,{"children":["$","$5",null,{"name":"Next.MetadataOutlet","children":"$@6"}]}]]}],"loading":null,"isPartial":false}
6:null
