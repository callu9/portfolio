1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T2f3b,<h2>1. 세션 기반 인증, 토큰 기반 인증</h2>
<p>세션 기반 인증은 사용자가 로그인을 하면, 서버가 세션을 생성하고 해당 세션 ID를 쿠키에 저장하여 클라이언트에 전달합니다. 이후 요청 시 이 쿠키를 통해 사용자를 식별하고, 이 세션 정보는 메모리나 데이터베이스 등에 저장되어 서버가 지속적으로 관리합니다.
토큰 기반 인증은 로그인 시 서버가 클라이언트를 인증하고 서명된 토큰을 생성하여 클라이언트에 전달합니다. 클라이언트는 이 토큰을 로컬 스토리지 등에 저장한 후, 이후 요청마다 헤더에 포함시켜 서버에 전송하고, 이 토큰을 서버가 검증만 하며 데이터베이스 등에 저장하진 않습니다.
비교하자면, 세션 기반 인증은 브라우저 쿠키에 저장되고, 토큰 기반 인증은 로컬 스토리지 등에 저장됩니다. 또한 세션의 경우 서버가 저장 및 만료 등과 같은 관리를 하지만, 토큰의 경우 서버가 별도 저장을 하지 않고 검증만 하며 토큰은 일정시간 후 자동 만료됩니다.</p>
<p><strong>유연성, 효율성 관련 내용 추가 필요</strong></p>
<h2>2. hydration에 대해 설명하고 Next.js에서 hydration 관련 주의할 점에 대해 설명</h2>
<p>하이드레이션(Hydration)은 서버에서 렌더링된 정적인 HTML 문서에 클라이언트 측 자바스크립트를 바인딩하여 인터렉티브하게 동작할 수 있도록 만드는 과정을 말합니다. 다시 말해, 서버 사이드 렌더링된 마크업 문서를 브라우저가 받아서, 리액트 등의 프레임워크가 해당 마크업에 이벤트 리스너와 상태 등을 연결하는 작업을 말합니다.
이때, Next.js에서는 초기 렌더링 시점의 데이터가 불일치 문제(날짜, 시간 등 클라이언트 전용 API를 서버에서 직접 사용하는 등), 동일한 초기 상태를 갖지 않고 useEffect, useLayoutEffect 등으로 SSR 결과를 재사용하지 못하도록 하는 문제를 주의해야 합니다. 이를 위해 동적 렌더링 요소는 클라이언트 전용 컴포넌트로 분리해야 합니다. 또한 클라이언트가 하이드레이션을 마치기 전까지는 페이지가 완전히 상호작용하지 않으므로, 불필요한 대형 컴포넌트의 SSR른 사용자 경험을 해칠 수 있다는 점에 유의해야 합니다.</p>
<h2>3. Static Site Generation의 특징과 어떤 경우에 활용하면 좋을지 설명</h2>
<p>Static Site Generation(SSG, 정적 사이트 배포)는 빌드 타임에 HTML을 생성해서 정적으로 저장해두는 방식을 말합니다. 사용자가 페이지를 요청하면 서버는 HTML을 즉시 반환하므로, 매우 빠른 응답 속도와 우수한 SEO 성능을 갖습니다. 단, SSG의 경우 빌드 타임에만 데이터 패칭이 진행되며 요청 시점이 아닌 빌드 시점에 API 호출을 수행하므로, 페이지 수가 많고 자주 바뀌는 경우는 빌드 시간이 오래 걸릴 수 있습니다.
결론적으로 콘텐츠가 자주 바뀌지 않는 정적페이지로서 블로그, 문서 페이지, 제품 소개 페이지 등에 적합하며, SEO 친화성 및 빠른 로딩 속도가 중요한 랜딩 페이지에 활용하는 것이 적합합니다.</p>
<h2>4. 쿠키, 세션 스토리지, 로컬 스토리지가 어떻게 다른지 그리고 어떤 상황에 사용하면 좋을지 설명해 주세요.</h2>
<p>쿠키 / 세션 스토리지 / 로컬 스토리지의 비교</p>
<ul>
<li>저장 위치: 브라우저 (서버로 전송됨) / 브라우저 (탭 단위) / 브라우저 (영구 저장)</li>
<li>만료 시점: 설정한 만료 시간 / 탭을 닫으면 삭제 / 명시적으로 지우기 전까지 유지</li>
<li>저장 용량: 4KB / 5KB / 5 ~ 10KB</li>
<li>활용 예시: 서버와 함께 인증 정보를 주고받을 때 사용 (로그인 상태 유지 등을 위해 JWT를 HttpOnly 쿠키에 저장) / 탭이 닫히면 사라져야 하는 임시 정보 저장 (폼 입력 내용 임시 저장, 페이지 이동 중 상태유지 등) / 장기적으로 클라이언트에 저장할 데이터 (다크모드 설정, 최근 본 항목, 비로그인 사용자의 장바구니 목록 등)</li>
</ul>
<h2>5. useMemo, useCallback 에 대해 설명하고, 어떤 경우에 사용하면 좋을지, 남용할 경우 발생할 수 있는 문제점을 설명해 주세요.</h2>
<p>seMemo은 비용이 많이드는 계산 결과를 메모이제이션하여 의존성 배열이 바뀌지 않으면 계산을 다시 하지 않고 기존값을 재사용함으로써, 계산량이 많은 함수(리스트 필터링, 정렬, 집계 등)의 반환값을 메모이제이션하여 불필요한 연산을 방지하는 목적으로 사용합니다.
useCallback은 함수를 메모이제이션하여 의존성이 바뀌지 않을 경우 동일한 함수 참조를 재사용합니다. 주로 자식 컴포넌트에 콜백을 props로 전달할 때 유용하며, 컴포넌트가 리렌더링 되더라도 같은 함수를 전달하므로 불필요한 자식 컴포넌트 리렌더링을 방지하는 목적으로 사용합니다.
위 두 사항을 남용할 경우, 코드 가독성과 유지보수성이 떨어져 복잡도가 올라갈 수 있습니다. 또한 메모이제이션을 통하여 메모리 사용이 증가할 수 있어 오히려 성능 저하를 유발할 수 있습니다.</p>
<h2>6. 리액트에서 배열을 렌더링할 때 key를 설정해야 하는 이유와 key를 설정할 때 주의할 점에 대해 설명해 주세요.</h2>
<p>React에서 .map()을 활용하여 배열을 렌더링할 때 key 속성을 설정하는 이유는, 변경사항을 효율적으로 감지하고 최소한의 DOM 업데이트를 수행하기 위함입니다. 즉, key는 React가 각 컴포넌트를 고유하게 식별할 수 있도록 도와주는 식별자 역할을 하여, 상태를 유지하면서 컴포넌트를 재사용하거나 변경할 수 있도록 하는 리액트의 Diffing 알고리즘의 기준이 됩니다.
주의할 점은 배열 인덱스 사용을 피하고, 데이터의 고유의 ID값을 key로 사용해야 한다는 점입니다. 리스트의 순서가 바뀌거나 요소가 추가/삭제될 때 인덱스를 사용하면 불필요한 리렌더링 혹은 버그가 발생할 수 있습니다. 특히 사용자 입력/편집 기능이 있는 리스트에서 주의해야 합니다.</p>
<h2>7. 리액트에서 Virtual DOM이 무엇인지, 이를 사용하는 이유는 무엇인지 설명해 주세요.</h2>
<p>React의 가상 돔(Virtual DOM)은 실제 브라우저의 DOM을 메모리 상 가볍게 복제한 자바스크립트 객체입니다. UI 상태가 바뀔 때마다 이전 가상돔과 비교하여 필요한 최소한의 변경만 수행하여 가상돔을 새롭게 생성합니다. 이때 Diffing 알고리즘으로 비교하고, Reconciliation 알고리즘을 통해 변경사항을 적용합니다.
가상 돔을 사용하는 이유는 성능 최적화를 위해서입니다. 실제 DOM 조작은 느리기 때문에, 가상 돔에서 먼저 변경 사항을 개선한 후 실제 DOM에 최소한의 변경사항을 적용하여 렌더링 성능을 향상시킬 수 있습니다.</p>
<h2>8. 프로젝트가 커짐에 따라 CSS 파일로 스타일링 할 때 발생할 수 있는 문제와 이를 해결하기 위한 방법들을 설명해 주세요. 그리고 본인이 선호하는 스타일링 방법과 이유에 대해서 설명해 주세요.</h2>
<p>프로젝트가 커질 경우, 전역 네임스페이스 충돌으로 인하여 의도하지 않은 스타일 덮어쓰기가 발생할 수 있으며 추적이 어려워질 수 있습니다. 따라서 리팩토링이 어렵고 재사용성이 낮다는 문제점을 가지고 있습니다.
저는 SCSS를 사용하여 구조적 네이밍 규칙을 통해 위 문제를 해결하고자 합니다. 중첩을 지원하기 때문에 페이지당 하나의 스타일시트를 만들 수 있으며, 또한 공통 스타일을 지정하거나 공통 색상/폰트 변수를 정의하고 사용하기에 편리하기 때문입니다. 주로 text-primary, surface-tertiary와 같은 클래스명을 사용하여 쉽게 스타일링할 수 있도록 클래스명을 별도로 정의하여 Elemet에 지정하여 스타일시트 파일을 작성할 때 내용을 덜 추가할 수 있도록 하기도 합니다.</p>
<h2>9. var, let, const 를 서로 비교해 설명해 주세요.</h2>
<p>var, let, const는 모두 변수 선언에 사용되는 변수 선언 키워드로, 값을 저장하고 필요할 때 불러오는 용도로 사용합니다. 이때, 스코프, 호이스팅, 재할당/재선언 가능성에 차이점을 갖고 있습니다.
var는 함수 스코프를 가지며, 선언과 초기화 모두 끌어올려지는 호이스팅의 특징을 갖고 있습니다. 재선언과 재할당이 모두 가능하고 사용 시점 전 접근, 즉 초기화 이전 접근 또한 가능하기에 호이스팅 관련 오류가 발생할 수 있어 현대 JS 개발에서 잘 사용하지 않습니다.
ES6 이후 나온 let, const 키워드는 var의 단점을 보완합니다. let은 블록 스코프를 가지며, 선언만 호이스팅되고 초기화는 호이스팅 되지 않습니다. 재선언은 같은 스코프 내에서 불가능하며, 재할당이 가능합니다. 초기화 전 접근은 ReferenceError 오류가 발생합니다. const는 let과 동일하게 블록 스코프, 선언만 호이스팅되며, 초기화 전 접근은 ReferenceError 오류가 발생합니다. 재선언/재할당이 불가능합니다.
이때, let과 const의 변수 초기화 이전 접근 시 Reference 오류가 발생하는 이유는 TDZ(Temporal Dead Zone) 때문입니다. 변수 선언은 끌어올려 지지만 초기화가 이루어지기 전까지 접근할 수 없기 때문에 이 구간을 TDZ라고 합니다.</p>
<h3>해설</h3>
<ul>
<li>스코프</li>
</ul>
<p>var 는 함수를 기준으로 스코프가 정해지고, let, const 는 코드 블록({ })을 기준으로 스코프가 정해집니다. var 을 특정 함수가 아닌 전역에서 사용하면 전역에서 var 변수로 선언된 값을 사용할 수 있습니다.</p>
<ul>
<li>중복 선언 허용 여부</li>
</ul>
<p>동일한 스코프 내에서 var는 변수의 중복 선언을 허용하고, 마지막에 선언한 값을 할당합니다. let, const 는 중복해서 선언하면 문법 오류가 발생합니다.</p>
<ul>
<li>선언되기 이전에 사용할 수 있는지 여부</li>
</ul>
<p>var 는 함수 스코프 기준으로 선언되기 이전에도 변수에 접근 가능합니다. 선언하기 이전에 값은 undefined 입니다. 이는 var 로 선언된 변수는 호이스팅(인터프리터가 코드를 실행하기 전에 함수, 변수, 클래스 또는 import의 선언문을 해당 범위의 맨 위로 이동시키는 과정)되기 때문입니다.</p>
<p>let, const 로 선언한 변수는 선언되기 이전에 사용할 수 없고, 참조 에러가 발생합니다. 이는 TDZ(Temporal Dead Zone)에 빠지기 때문입니다.</p>
<h2>10. 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임에 대해 설명해 주세요.</h2>
<p>이벤트 버블링은 이벤트가 가장 자식 요소에서 부모 요소로 전파되는 방식을 말하며, 이벤트 캡처링은 부모 요소에서 자식 요소로 전파되는 방식을 말합니다. 이벤트 위임의 경우, 공통 부모 요소에 이벤트 리스터를 등록해 실제 클릭된 자식 요소를 분기 처리하는 방식으로, 이벤트가 자식요소에서 시작해 부모로 버블링 되는 특성을 이용, 즉 이벤트 버블링을 활용합니다. 동일한 이벤트를 모든 자식요소가 사용할 때, 모든 자식요소에 하나하나 이벤트를 등록하지 않고 이벤트 위임을 사용하여 부모 요소에 이벤트를 등록해 분기처리를 유도하면 유용합니다.</p>
0:{"buildId":"zkizE9bspPalFbAzzM_bK","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
