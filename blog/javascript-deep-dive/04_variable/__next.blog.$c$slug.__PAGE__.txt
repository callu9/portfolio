1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T21dd,<h1>4. 변수</h1>
<h2>4.1. 변수란?</h2>
<h3>변수 (variable)</h3>
<ul>
<li>프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념</li>
<li>하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li>
<li>프로그래밍 언어에서 값을 저장하고 참고하는 메커니즘으로, <strong>값의 위치를 가리키는 상징적인 이름</strong></li>
<li>자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.</li>
</ul>
<pre><code class="language-js">//  변수명    변수 값
var result = 10 + 20;
</code></pre>
<h3>할당 (assignment)</h3>
<p>변수에 값을 저장하는 것</p>
<h3>참조 (reference)</h3>
<p>변수에 저장된 값을 읽어 들이는 것</p>
<h2>4.2. 식별자</h2>
<h3>식별자 (identifier)</h3>
<ul>
<li>식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름, 즉 <strong>메모리 주소</strong>에 붙인 이름으로, 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다.</li>
<li>메모리 상 존재하는 어떤 값(변수, 함수, 클래스 등)을 식별할 수 있는 이름은 모두 식별자라고 한다.</li>
<li>식별자는 네이밍 규칙을 준수해야 하며, 선언(declaration)에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.</li>
</ul>
<h2>4.3. 변수 선언</h2>
<ul>
<li>변수 선언(variable declaration)이란 변수를 생성하는 것을 말한다.</li>
<li>값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)하여 값을 저장할 수 있게 준비</li>
<li>변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전 까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호된다.</li>
<li>변수를 사용하려면 반드시 선언이 필요하며, 선언 시 <code>var</code>, <code>let</code>, <code>const</code> 키워드를 사용한다.</li>
</ul>
<h3>ES5 vs. ES6</h3>
<ul>
<li>ES5까지는 <code>var</code> 키워드가 유일한 변수 선언 키워드, ES6에서 <code>let</code>, <code>const</code> 도입</li>
<li>var 키워드의 단점: 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원</li>
<li>ES6는 ES5의 상위 집합(superset)으로, 권장하지는 않지만 var 키워드를 사용할 수 있으며, ES6 이전 사양으로 구현된 코드더라도 ES6 기반의 자바스크립트 엔진에서 모두 정상적으로 동작한다.</li>
</ul>
<h3>변수 선언 과정</h3>
<ol>
<li>선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.</li>
<li>초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.</li>
</ol>
<ul>
<li>
<p>변수 이름을 비롯한 모든 식별자는 key/value 형식인 객체로 실행 컨텍스트에 등록되어 관리된다.(자바스크립트 엔진이 변수를 관리하는 매커니즘은 <a href="./13_scope.md">13. 스코프</a>, <a href="./23_execution_context.md">23. 실행 컨텍스트</a> 참고)</p>
</li>
<li>
<p><code>var</code> 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.</p>
</li>
<li>
<p>만약 선언하지 않은 식별자에 접근하면 <code>ReferenceError</code>(참조 에러) 발생</p>
</li>
</ul>
<h2>4.4. 변수 선언의 실행 시점과 변수 호이스팅</h2>
<pre><code class="language-js">console.log(score); // undefined

var score; // 변수 선언문
</code></pre>
<h3><code>ReferenceError</code>(참조 에러)가 발생하지 않는 이유</h3>
<p>변수선언이 소스코드가 한줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문.</p>
<p>자바스크립트 엔진은 실행에 앞서 먼저 소스코드의 평가 과정을 거치는데, 이때 변수 선언문, 함수 선언문 등 모든 선언문을 소스코드에서 찾아내 먼저 실행한다. 소스코드의 평가 과정이 끝나면 비로소 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.</p>
<h3>호이스팅 (hoisting)</h3>
<ul>
<li>변수, 함수, 클래스의 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징.</li>
<li><code>var</code>, <code>let</code>, <code>const</code>, <code>funtion</code>, <code>funtion*</code>, <code>class</code> 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)은 호이스팅 된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.</li>
</ul>
<h2>4.5. 값의 할당</h2>
<h3>할당 (assignment)</h3>
<p>할당 연산자 <code>=</code>를 사용하여 우변의 값을 좌변의 변수에 할당한다.
자바스크립트 엔진은 변수 선언과 값의 할당 2개의 문으로 나누어 각각 실행한다.</p>
<pre><code class="language-js">var score = 80; // 변수 선언과 값의 할당
                //    ↓
var score;      // 변수 선언
score = 80;     // 값의 할당
</code></pre>
<p>변수 선언과 값의 할당 실행 시점이 다르다.</p>
<ul>
<li>변수 선언: 런타임(소스코드가 순차적으로 실행되는 시점) 이전에 먼저 실행</li>
<li>값의 할당: 런타임에 실행.
<ul>
<li>주의. undefined가 저장되어 있던 이전의 메모리 공간을 지우는 것이 아니라 새로운 메모리 공간을 확보하여 값을 저장한다.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">console.log(score); // undefined

var score;  // ① 변수 선언
score = 80; // ② 값의 할당

console.log(score); // 80
</code></pre>
<h2>4.6. 값의 재할당</h2>
<ul>
<li>재할당: 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것</li>
</ul>
<pre><code class="language-js">var score = 80; // 변수 선언과 값의 할당
score = 90;     // 값의 재할당
</code></pre>
<ul>
<li>참고: 값을 재할당할 수 없어서 값을 변경할 수 없다면, 변수가 아니라 상수(constant). 상수는 한번 정해지면 변하지 않는 값이며, 즉 단 한 번만 할당할 수 있는 변수다.</li>
<li>주의: 재할당 시 이전의 메모리 공간을 지우는 것이 아니라 새로운 메모리 공간을 확보하여 값을 저장하며, 이전 값은 불필요하여 가비지 콜렉터에 의해 메모리에서 자동 해제되나, 메모리에서 언제 해제될지는 예측할 수 없다.</li>
</ul>
<h3>가비지 콜렉터 (garbage collector)</h3>
<p>애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는(어떤 식별자도 참조하지 않는) 메모리를 해제(release)하는 기능을 말한다.
자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수(memory leak) 방지한다.</p>
<h2>4.7. 식별자 네이밍 규칙</h2>
<ul>
<li>식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(<code>_</code>), 달러 기호(<code>$</code>)를 포함할 수 있다.</li>
<li>단, 식별자는 숫자로 시작하는 것은 허용하지 않으며, 특수문자를 제외한 문자, 언더스코어(<code>_</code>), 달러 기호(<code>$</code>)로 시작해야 한다.</li>
<li>예약어는 식별자로 사용할 수 없다.</li>
</ul>
<h3>예약어 (reserved word)</h3>
<p>프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어. (await, break, case, catch, class, const, continue, debugger, default, delete, do, else, enum, export, extends, false, finally, for, function, if...)</p>
<h3>네이밍 컨벤션 (naming convention)</h3>
<pre><code class="language-js">// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
</code></pre>
<p>일반적인 사용 범위</p>
<ul>
<li>카멜 케이스: 변수, 함수</li>
<li>파스칼 케이스: 생성자 함수, 클래스명</li>
</ul>
0:{"buildId":"NBOTbsJWgipKuL85VBogm","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
