1:"$Sreact.fragment"
6:I[22016,["/_next/static/chunks/c425561422a45908.js","/_next/static/chunks/796e69ae18b2784c.js"],""]
7:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
2:T1306,<h1>5. 표현식과 문</h1>
<h2>5.1. 값</h2>
<p>값(value): 표현식(expression)이 평가(evaluate)되어 생성된 결과</p>
<ul>
<li>평가: 식을 해석해서 값을 생성하거나 참조하는 것을 의미</li>
</ul>
<pre><code class="language-js">// 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.
var sum = 10 + 20;
</code></pre>
<h2>5.2. 리터럴</h2>
<p>리터럴(literal): 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)으로, 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 미리 약속된 기호('', "", ., [], {}, // 등)으로 표기한 코드</p>
<ul>
<li>자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성한다. 즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다.</li>
</ul>
<p>| 리터럴 | 예시 | 비고 |
| --- | --- | --- |
| 정수 리터럴 | <code>100</code> |  |
| 부동소수점 리터럴 | <code>10.5</code> |  |
| 2진수 리터럴 | <code>0b01000001</code> | <code>0b</code>로 시작 |
| 8진수 리터럴 | <code>0o101</code> | ES6에서 도입. <code>0o</code>로 시작 |
| 16진수 리터럴 | <code>0x41</code> | ES6에서 도입. <code>0x</code>로 시작 |
| 문자열 리터럴 | <code>'Hello'</code>, <code>"World"</code> |  |
| 불리언 리터럴 | <code>true</code>, <code>false</code> |  |
| null 리터럴 | <code>null</code> |  |
| undefined 리터럴 | <code>undefined</code> |  |
| 객체 리터럴 | <code>{name: 'Lee', address: 'Seoul'}</code> |  |
| 배열 리터럴 | <code>[1, 2, 3]</code> |  |
| 함수 리터럴 | <code>function() {}</code> |  |
| 정규 표현식 리터럴 | <code>/[A-Z]+/g</code> |  |</p>
<h2>5.3. 표현식</h2>
<p>표현식(expression): 값으로 평가될 수 있는 문(statement)</p>
<ul>
<li>표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.</li>
</ul>
<pre><code class="language-js">// 리터럴 표현식
10
'Hello'

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
</code></pre>
<h2>5.4. 문</h2>
<p>문(statement): 프로그램을 구성하는 기본단위이자 최소 실행 단위.</p>
<ul>
<li>명령문이라고도 부른다. 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.</li>
<li>문은 여러 토큰으로 구성된다. (토큰: token, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소)</li>
</ul>
<pre><code class="language-js">// 변수 선언문
var x;

// 표현식 문(할당문)
x = 5;

// 함수 선언문
function foo () {}

// 조건문
if (x > 1) { console.log(x); }

// 반복문
for (var i = 0; i &#x3C; 2; i++) { console.log(i); }
</code></pre>
<h2>5.5. 세미콜론과 세미콜론 자동 삽입 기능</h2>
<p>자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실핸한다.</p>
<ul>
<li>단, 0개 이상의 문을 중괄호로 묶은 코드 블록(<code>{...}</code>) 뒤에는 세미콜론을 붙이지 않는다. (if 문, for 문, 함수 등) 이러한 코드 블록은 자체 종결성(self closing)을 갖기 때문이다.</li>
</ul>
<p>자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 **세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)**이 암묵적으로 수행되기 때문에, 세미콜론은 생략 가능하다.</p>
<h2>5.6. 표현식인 문과 표현식이 아닌 문</h2>
<ul>
<li>표현식인 문이란? 값으로 평가될 수 있는 문 (예: 할당문)</li>
<li>표현식이 아닌 문이란? 값으로 평가될 수 없는 문 (예: 변수 선언문)
<ul>
<li>표현식인 문은 값으로 평가되므로 변수에 할당할 수 있지만, 
표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x;

// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.
// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
x = 1 + 2;

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var
</code></pre>
<h3>완료값 (completion value)</h3>
<p>크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 출력되는 undefined를 완료값이라고 하며, 표현식의 평과 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.</p>
0:{"buildId":"NBOTbsJWgipKuL85VBogm","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"min-h-screen pt-32 pb-20","children":["$","div",null,{"className":"section-container max-w-3xl","children":["$","article",null,{"className":"card bg-white/70 p-8 backdrop-blur-sm md:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"text-text-primary mb-4 text-4xl font-bold md:text-5xl"}],["$","div",null,{"className":"text-text-secondary flex items-center gap-4","children":[["$","time",null,{}],["$","span",null,{"children":"•"}],["$","span",null,{"children":["읽기 시간: 약 ","-","분"]}]]}]]}],["$","div",null,{"className":"prose prose-invert prose-headings:text-text-primary prose-p:text-text-secondary prose-a:text-secondary-coral hover:prose-a:text-secondary-peach prose-code:text-secondary-coral prose-code:bg-secondary-mint/20 prose-code:px-2 prose-code:py-1 prose-code:rounded max-w-none","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$2"}}]}],"$L3"]}]}]}],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
3:["$","footer",null,{"className":"border-secondary-peach/30 mt-12 border-t pt-8","children":["$","$L6",null,{"href":"/blog","className":"text-secondary-coral hover:text-secondary-peach font-medium transition-colors","children":"← 블로그로 돌아가기"}]}]
4:["$","script","script-0",{"src":"/_next/static/chunks/796e69ae18b2784c.js","async":true}]
5:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
